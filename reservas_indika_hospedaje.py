# -*- coding: utf-8 -*-
"""reservas_indika_hospedaje.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MU0zWQHNC-cp6kbx0gKqYu9tw3Hla6Xh
"""

import streamlit as st
from datetime import date, timedelta
import time

# --- Configuraci√≥n y Simulaci√≥n de Backend ---
# T√≠tulo y configuraci√≥n de la p√°gina (en espa√±ol)
st.set_page_config(
    page_title="Sistema de Reserva de Alojamiento",
    layout="centered",
    initial_sidebar_state="expanded"
)

# Diccionario para limitar el n√∫mero de hu√©spedes por tipo de reserva
MAX_GUESTS = {
    "Caba√±a 1 (M√°x. 10 personas)": 10,
    "Caba√±a 2 (M√°x. 6 personas)": 6,
    "Espacio para Camping (M√°x. 10 personas)": 10
}

# SIMULACI√ìN DE FECHAS RESERVADAS (para demostrar la validaci√≥n de disponibilidad)
# En un entorno real, esta informaci√≥n vendr√≠a de una base de datos (Firestore o similar).
SIMULATED_BOOKED_DATES = {
    "Caba√±a 1 (M√°x. 10 personas)": [date(2025, 12, 24), date(2025, 12, 25), date(2025, 12, 26)],
    "Caba√±a 2 (M√°x. 6 personas)": [date(2025, 12, 1), date(2025, 12, 2)],
    "Espacio para Camping (M√°x. 10 personas)": [] # El camping siempre est√° disponible para la simulaci√≥n
}


def check_availability(reservation_type, start_date, end_date):
    """
    Simula la verificaci√≥n de disponibilidad en el calendario.
    Retorna True si la reserva est√° disponible, False si hay fechas ocupadas.
    """
    if start_date > end_date:
        return False, "La fecha de salida no puede ser anterior a la fecha de llegada."

    # Crear un rango de fechas a reservar
    delta = end_date - start_date
    dates_to_check = [start_date + timedelta(days=i) for i in range(delta.days + 1)]

    booked = SIMULATED_BOOKED_DATES.get(reservation_type, [])

    # Verificar si alguna fecha del rango est√° en las fechas simuladas como ocupadas
    clashing_dates = [d for d in dates_to_check if d in booked]

    if clashing_dates:
        clash_str = ", ".join([d.strftime("%Y-%m-%d") for d in clashing_dates])
        return False, f"Lo sentimos, las siguientes fechas est√°n ocupadas para la {reservation_type}: {clash_str}. Por favor, elija otro rango."

    return True, "Fechas disponibles."

def handle_submission(data):
    """
    Procesa la reserva si todas las validaciones son exitosas.
    Simula el env√≠o de correo al usuario y la notificaci√≥n al hotel.
    """

    st.success("üéâ ¬°Reserva Exitosa! Procesando pago y env√≠o de confirmaci√≥n...")
    st.balloons()

    # 1. Simulaci√≥n de procesamiento de pago
    st.subheader(f"Pago Requerido: {data['metodo_pago']}")

    if data['metodo_pago'] == "Bancolombia (Cuenta de Ahorros)":
        st.info("Para completar su reserva, por favor transfiera el valor total a la siguiente cuenta de ahorros Bancolombia: **000-0000000-00**. ¬°Recuerde enviar el comprobante!")
    elif data['metodo_pago'] == "Nequi (N√∫mero de Celular)":
        st.info("Para completar su reserva, por favor transfiera el valor total al siguiente n√∫mero de Nequi: **300-5555555**. ¬°Recuerde enviar el comprobante!")

    # 2. Simulaci√≥n de Env√≠o de Email/Notificaci√≥n al Hotel
    st.markdown("---")
    st.subheader("Resumen de su Reserva")

    # Simulaci√≥n de la notificaci√≥n al correo del hotel (se usar√≠a un servicio API externo)
    with st.spinner('Simulando env√≠o de correo de confirmaci√≥n y notificaci√≥n al hotel...'):
        time.sleep(2)

    st.info(f"Se ha simulado el env√≠o de un correo de confirmaci√≥n a: {data['email']}. Y una notificaci√≥n con todos los detalles ha sido enviada al correo del hotel (simulado).")

    # Mostrar el resumen de la reserva al usuario
    st.write(f"**Tipo de Reserva:** {data['tipo_reserva']}")
    st.write(f"**Fechas:** Desde {data['fecha_llegada'].strftime('%d/%m/%Y')} hasta {data['fecha_salida'].strftime('%d/%m/%Y')}")
    st.write(f"**Hu√©spedes:** {data['huespedes']} persona(s)")

    st.markdown("### Datos del Hu√©sped Principal")
    col1, col2 = st.columns(2)
    with col1:
        st.write(f"**Nombre:** {data['nombre_completo']}")
        st.write(f"**Identificaci√≥n:** {data['identificacion']}")
        st.write(f"**Celular:** {data['celular']}")
    with col2:
        st.write(f"**Edad:** {data['edad']} a√±os")
        st.write(f"**Email:** {data['email']}")
        st.write(f"**M√©todo de Pago:** {data['metodo_pago']}")

    st.markdown("---")
    st.caption("¬°Gracias por reservar con nosotros! Espere la confirmaci√≥n final al completar el pago.")


# --- Interfaz de Usuario de Streamlit ---

st.title("üèïÔ∏è Reservas: INDIKA HOSPEDAJE")
st.markdown("Por favor, complete el siguiente formulario para solicitar su reserva.")

# Usamos st.form para agrupar todas las entradas y manejarlas en un solo env√≠o
with st.form(key='reservation_form'):

    st.subheader("1. Informaci√≥n del Hu√©sped que hace la reserva")

    # 1. Nombre y apellido
    nombre_completo = st.text_input("Nombre y Apellido completos", key='nombre')

    # 2. Edad (Validaci√≥n: debe ser mayor de edad)
    # Usamos st.number_input para asegurar que es un n√∫mero
    edad = st.number_input("Edad", min_value=1, max_value=120, value=18, key='edad')

    # 3. N√∫mero de identificaci√≥n
    identificacion = st.text_input("N√∫mero de Identificaci√≥n (C√©dula)", key='id')

    # 4. N√∫mero de celular
    celular = st.text_input("N√∫mero de Celular (Ej: 3001234567)", key='celular')

    # 5. Correo electr√≥nico
    email = st.text_input("Correo Electr√≥nico (Para recibir el resumen de su reserva)", key='email')

    st.subheader("2. Detalles de la Reserva")

    # 6. Tipo de reserva
    tipo_reserva = st.selectbox(
        "Tipo de Alojamiento",
        options=list(MAX_GUESTS.keys()),
        key='tipo_reserva'
    )

    # 7. D√≠as en los que desea reservar
    today = date.today()

    col_date1, col_date2 = st.columns(2)
    with col_date1:
        fecha_llegada = st.date_input(
            "Fecha de Llegada",
            min_value=today,
            value=today + timedelta(days=7),
            key='fecha_llegada'
        )

    with col_date2:
        # Aseguramos que la fecha de salida sea al menos la fecha de llegada
        fecha_salida = st.date_input(
            "Fecha de Salida",
            min_value=fecha_llegada,
            value=fecha_llegada + timedelta(days=1),
            key='fecha_salida'
        )

    # 8. N√∫mero de hu√©spedes (m√≠nimo 1, m√°ximo seg√∫n el tipo de reserva)
    max_huespedes = MAX_GUESTS.get(tipo_reserva, 1) # Obtener el m√°ximo seg√∫n el tipo
    huespedes = st.number_input(
        "N√∫mero de Hu√©spedes",
        min_value=1,
        max_value=max_huespedes,
        value=1,
        key='huespedes',
        help=f"M√°ximo de hu√©spedes permitido: {max_huespedes}."
    )

    st.subheader("3. M√©todo de Pago")

    # 9. M√©todo de pago electr√≥nico
    metodo_pago = st.selectbox(
        "Seleccione M√©todo de Pago Electr√≥nico (Pago Anticipado Requerido)",
        options=[
            "Bancolombia (Cuenta de Ahorros)",
            "Nequi (N√∫mero de Celular)"
        ],
        key='metodo_pago'
    )

    # Bot√≥n de env√≠o del formulario
    submit_button = st.form_submit_button(label='‚úÖ Realizar Reserva y Pagar')

# --- L√≥gica de Validaci√≥n al Enviar el Formulario ---

if submit_button:

    # 1. Validaci√≥n de campos obligatorios
    if not all([nombre_completo, identificacion, celular, email]):
        st.error("üö® Error: Debe completar todos los campos de informaci√≥n.")
        st.stop()

    # 2. Validaci√≥n de Edad
    if edad < 18:
        st.error("üö´ Error: El hu√©sped que hace la reserva debe ser mayor de 18 a√±os.")
        st.stop()

    # 3. Validaci√≥n de Fechas (Rango y Disponibilidad)

    # A. Rango de fechas
    if fecha_llegada > fecha_salida:
        st.error("üö´ Error de Fechas: La fecha de salida no puede ser anterior a la fecha de llegada.")
        st.stop()

    # B. Disponibilidad
    is_available, availability_msg = check_availability(tipo_reserva, fecha_llegada, fecha_salida)

    if not is_available:
        st.error(f"üö´ Error de Disponibilidad: {availability_msg}")
        st.stop()

    # 4. Validaci√≥n de Hu√©spedes (ya cubierta por el 'max_value' en number_input, pero se reconfirma)
    if huespedes < 1 or huespedes > MAX_GUESTS[tipo_reserva]:
        st.error(f"üö´ Error de Hu√©spedes: El n√∫mero de hu√©spedes ({huespedes}) debe estar entre 1 y {MAX_GUESTS[tipo_reserva]} para la opci√≥n seleccionada.")
        st.stop()

    # Si todas las validaciones son correctas, procesar la reserva
    reservation_data = {
        'nombre_completo': nombre_completo,
        'edad': edad,
        'identificacion': identificacion,
        'celular': celular,
        'email': email,
        'tipo_reserva': tipo_reserva,
        'fecha_llegada': fecha_llegada,
        'fecha_salida': fecha_salida,
        'huespedes': huespedes,
        'metodo_pago': metodo_pago
    }

    # Llamar a la funci√≥n que simula el manejo del backend y la confirmaci√≥n
    handle_submission(reservation_data)

st.sidebar.header("Estado de Disponibilidad (Simulado)")
st.sidebar.markdown("Las siguientes fechas se consideran **ocupadas** en nuestra simulaci√≥n:")

for res_type, dates in SIMULATED_BOOKED_DATES.items():
    if dates:
        st.sidebar.markdown(f"**{res_type.split('(')[0].strip()}**:")
        for d in dates:
             st.sidebar.write(f"- {d.strftime('%Y-%m-%d')}")

    if not any(SIMULATED_BOOKED_DATES.values()):
        st.sidebar.info("Todas las fechas est√°n disponibles para esta demostraci√≥n.")